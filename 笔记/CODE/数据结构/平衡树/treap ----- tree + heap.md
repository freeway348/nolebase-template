# 一、前置知识
## （一）二叉搜索树（BST）
### 1. 全称：Binary Search Tree
### 2. 特点：
1. 当前节点的左子树中的任何一个点的权值 < 当前节点的权值
2. 当前节点的右子树中的任何一个点的权值 > 当前节点的权值
3. 一般情况下，BST中没有相同权值，如果存在相同权值，那么就在每一个节点上用计数器存储该权值的出现次数
4. 着重点在BST的**中序遍历**（按照左子树，根节点，右子树的顺序遍历），最终得到的数字序列从左到右是从小到大的数字序列
5. 本质上是**动态维护**一个***有序***序列
### 3.基本操作
1. 插入
2. 删除
3. 找某一节点的前驱/后继
	1. 前驱：中序遍历中的前一个位置
	2. 后继：中序遍历中的后一个位置
4. 找最大/最小值
以上四点是set类型支持的操作，如果只涉及以上四点要求，那么该平衡树直接用set写就可以了
---
5. 求某个值的排名
6. 求排名第 k 的数是哪个
7. 比某个数小的最大值(lower_bound 的实现)
8. 比某个数大的最小值
## （二）堆
- 大根堆
# 二、基本介绍
## （一）核心思想

- 让BST尽量随机，使得BST的期望高度为$log(n)$
## （二）节点信息
```
Node
{
	int l,r; // 左、右儿子的编号
	int key,val; // key：用于排序的关键字，val：优先级，大根堆中的value值（随机值）
}tr[N];
```
### （三）例题解析
#### 1. 原题
- 题目链接：[P3369 【模板】普通平衡树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3369)
#### 2. 