# 2.2.3 定点数的加减运算

---
### 一、定点数的加减运算
#### 1. 原码的加减运算（了解即可）

![](assets/Pasted%20image%2020250525213558.png)
只有当"正+正"或"负+负"时才可能发生溢出（最高数值位发生进位，导致符号位改变）

但`计算机中通常使用补码进行计算，所以对原码的计算仅作了解即可`

#### 2. 补码的加减运算
##### (1)补码的加减运算基本公式

- 补码加减运算的公式：（设机器字长为 n+1 ）
	1. $[A+B]_补=[A]_补+[B]_补 \; (mod\; 2^{n+1})$
	2. $[A-B]_补=[A]_补+[-B]_补 \; (mod\; 2^{n+1})$
- 特点： 
	1. 按二进制运算规则进行，逢二进一
	2. 遇到加减法按公式计算
	3. 符号位与数值位一起参与运算，运算结果的符号位也在运算中直接得出
	4. 最终运算结果的高位丢弃，**保留n+1位**，`运算结果也是补码`
##### (2)补码的溢出判断

- 前提：当且仅当两个`符号相同的数相加`或`两个符号相反的数相减`时才可能发生溢出（A-B可看作A+(-B)，所以也可记住，符号相同的两数相加就可能发生溢出）
	- 即：只有"正数+正数"才会发生上溢：正+正=负；只有"负数+负数"才可能发生下溢：负+负=正
补码的加减溢出判断有三种方式：

###### a. 采用一位符号位


###### b. 采用双符号位

###### c. 采用一位符号位根据**数值位的进位情况**判断溢出



### 二、无符号数的加减运算
#### 加法

![](assets/Pasted%20image%2020250525215958.png)
#### 减法

![](assets/Pasted%20image%2020250525220320.png)

在 8 位寄存器中，数值最多能表示 0 ~ 255，也就是 mod 256，那么假设在该寄存器中存储了一个数A，则 $A + [A]_\text{补} = 256$
无符号数求补数：**全部位**取反后 + 1
	假设将 A 取反后得到 B，则 A + B = 255 必定成立，故 + 1 即可得到 256

#### 溢出判断
![](assets/Pasted%20image%2020250525220419.png)
考试遇到判断`无符号数`溢出问题，一般使用手算方法，而计算机内部判断无符号数加减是否溢出的方法就如红蓝两行所述

##### 加法溢出判断

![](assets/Pasted%20image%2020250525220804.png)
##### 减法溢出判断

同样的，按减法运算进行计算，若按位相加后，最高位进位为0，则发生溢出

![](assets/Pasted%20image%2020250525221229.png)
