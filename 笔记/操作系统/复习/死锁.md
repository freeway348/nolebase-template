# 死锁
---

### 一、基本概念

- 死锁：各进程**互相等待对方手里的资源**，导致各进程都阻塞，无法向前推进的现象。
	- 多进程（多线程），两个或两个以上都占有资源，因争夺资源而导致的阻塞，如果没有外力作用，将一直阻塞
	- 死锁会浪费大量系统资源，甚至导致系统崩溃
#### 1. 死锁与饥饿的区别

|     |       共同点       |                                       区别                                        |
| :-: | :-------------: | :-----------------------------------------------------------------------------: |
| 死锁  | 都是进程无法向前推进导致的现象 | 死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那**至少有两个或两个以上的进程**同时发生死锁。另外，发生死锁的进程一定处于**阻塞**状态 |
| 饥饿  |       同上        |         **可能只有一个进程**发生饥饿。发生饥饿的进程既可能是阻塞态（如：长期得不到I/O设备），也可能是就绪态（长期得不到处理机）         |
#### 2. 产生死锁的必要条件

```
死锁只有同时满足以下四个条件才会发生，如果有一个条件不满足，就不会发生
```
1. 互斥条件：多个进程（或线程）不能同时使用同一个资源
	- 只有对必须**互斥**使用的资源的争抢才可能导致死锁（如：哲学家的筷子，打印机设备）
2. 请求和保持条件（持有和等待条件）：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求资源的进程被阻塞，但又对自己占有的资源保持不放
3. 不剥夺条件：进程所获取的资源在未使用完之前，不能由其他进程强行夺走，**只能主动释放**
4. 循环等待条件（环路等待条件）：在死锁发生时，两个进程获取资源的顺序一定构成了一个环路
	- `发生死锁时一定有循环等待，但是发生循环等待时未必死锁`
#### 3. 死锁的预防

- 死锁的处理：
	- 一是不允许死锁的发生，一种是静态策略（预防死锁），另一种是动态策略（避免死锁）
	- 二是允许死锁的发生，发生后再进行检测和处理
##### (1)预防死锁

- 破坏死锁产生的四个必要条件中的一个或者多个
- 是一种保守策略，宁可浪费/闲置一些系统资源，按序分配

##### (2)避免死锁

- 用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）
- 在动态分配过程中，用某种方法防止系统进入不安全状态
- 该方法是预防和检测的折中，边运行边检测判断
- 缺点：必须知道后续的资源需求，进程不能被长时间阻塞

##### （3）死锁的检测和解除

- **允许死锁的发生**，但OS会负责检测出死锁的发生，然后采用某种措施来解除死锁
- 定期检查
- 不再占用进程初始化的时间
###### 1. 破坏互斥条件

- 将只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。
	- 如：SPOOLing计数，OS可以通过SPOOLing技术将独占设备在逻辑上改造成共享设备
- 缺点：不是所有资源都能改造成共享资源，因此，很多时候都无法破坏互斥条件
###### 2. 破坏不剥夺条件

- 当某个进程请求新的资源得不到满足时，它必须要立即释放当前保持的所有资源，待以后需要时再重新申请，即便某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件
- 缺点：
	1. 实现较复杂
	2. 释放已获得的资源可能导致前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU
	3. 反复地申请和释放资源会增加系统开销，降低系统吞吐量
	4. 只要暂时得不到该资源，那么之前获得的资源都需要被释放，以后再重新申请。如果一直发生这种情况，则可能发生进程的饥饿

###### 3. 破坏请求和保持条件

- 可以采用静态分配的方式，即：进程在运行前一次性申请完它所需的所有资源，在它的资源未满足前，不让它投入运行。一旦投入运行，则这些资源都归它所有，该进程就不会再请求其他系统资源了。
- 缺点：有些资源可能只需要用很短的时间，因此如果进程的整个运行过程都保持着所有资源，就可能会造成严重的资源浪费，资源利用率低。另外，该策略也可能会导致某些进程的饥饿

###### 4. 破坏