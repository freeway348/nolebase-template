# 引论

---

### 一、操作系统的基本概念[^3]

- 控制和管理整个计算机的硬件和软件资源，合理地组织调度计算机的工作和资源的分配，提供给用户和其他软件比较方便的接口和环境
- 是计算机系统中**最基本的系统软件**
	- 注意！！！ OS**不是硬件**！！！
- 从下至上的计算机系统结构：裸机 $\Rightarrow$ OS（操作系统） $\Rightarrow$ 应用程序 $\Rightarrow$ 用户
	- ![](assets/Pasted%20image%2020241124192838.png)
	- 计算机系统：如win11，linux等
	- 裸机：硬件，如CPU，输入输出设备等
#### 操作系统（OS）的功能

- 对上层结构：为应用程序和用户提供方便的接口和环境
- 对下层结构：分配硬件资源和软件资源，控制和管理计算机的硬件和软件
- 是最靠近裸机的一层，即是**最基本的系统软件**

### 二、操作系统的基本特征[^4]

```
操作系统的基本特征包括：并发、共享、虚拟、同步
```

#### 1. 并发

```
操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的
```
##### 定义

- 指两个或多个事件在**同一时间间隔**发生。宏观上看是同时发生的，微观上是交替进行的

##### 区分：并行

- 并行指的是具有同时进行运算和操作的特性，在**同一时刻**能完成两种或以上的工作

##### 重要考点[^6]

- **单核CPU**同一时刻只能执行**一个程序**，各个程序只能**并发**地执行
- **多核CPU**同一时刻可以同时执行**多个程序**，多个程序可以**并行**地执行
	- 例如：`4`核CPU可以同时（同一时刻）**并行**运行四个程序，但当需要运行四个以上，如：五个、六个程序时，仍然需要**并发**执行，所以操作系统的并发性依然是不可缺少的

#### 2. 共享
##### 定义

- 系统中的资源可供内存中多个**并发执行**的进程共同使用
##### 分类

1. 互斥共享方式：资源在特定时间间隔内**只允许一个进程**访问该资源
2. 同时共享方式：一个时间段内**允许多个进程**同时对某些资源进行访问
	- 宏观上看是同时发生的，而在微观上可能是交替进行的

[^7]
>[!tip] 重点
>并发和共享是操作系统中两个**最基本的特征**，两者之间是互为存在的关系：
>>1. 如果失去并发性，即：系统中只有一个进程在运行，则共享性就失去了意义
>>2. 如果失去共享性，则并发进行的进程无法共享资源
>
>没有并发和共享，就谈不上虚拟和异步

#### 3. 虚拟
##### 定义

- 一个物理意义上的实体变为若干个虚拟逻辑上的对应物
	- 物理实体是实际存在的，逻辑上的对应物是用户感受到的
	- 用于实现虚拟这一特性的技术，称为虚拟技术
		- 虚拟存储器技术是通过多道程序设计技术，采用让多道程序并发执行的方法，来分时使用一个处理器，但在用户看来（逻辑上）就是同时进行的
- 技术分类：
	1. 空分复用技术（如：虚拟存储器技术）
	2. 时分复用技术（如：虚拟处理器）
		- 如果失去了并发性，那么就不存在虚拟性了

#### 4. 异步
##### 定义

- 在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停（做一部分停一会），以不可预知的速度前进，这就是进程的异步性
	- 如果失去了并发性，即：系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性

### 三、操作系统的功能和接口
#### 1. 作为计算机系统资源的管理者

- 对资源进行管理：**处理机管理（进程管理）、存储器管理**、文件管理、设备管理[^1]

##### （1）处理机管理

- 在**多道程序**环境下，处理机的分配和运行都**以进程为基本单位**，所以也可将处理机管理归纳为为对进程的管理
- 进程管理的主要功能：进程控制、进程同步、进程通信、死锁处理、处理机调度等

##### （2）存储器管理

- 为了给多道程序的运行提供良好环境，方便用户使用并**提高内存利用率**
- 主要功能包括：内存分配和回收、地址映射、内存保护和共享、内存扩充等

##### （3）文件管理

- 负责文件管理的部分称为**文件系统**
- 文件管理包括：文件存储空间的管理、目录管理及文件读写管理和保护等

##### （4）设备管理

- 主要任务：完成用户的 I/O 请求，方便用户使用设备，并**提高设备利用率**
- 主要包括：缓冲管理、设备分配、设备处理和虚拟设备等

#### 2. 作为计算机硬件系统和用户之间的接口

- 接口主要分为两类：
	1. 命令接口：直接进行访问
	2. 程序接口：间接进行访问

##### （1）命令接口

- 按作业控制方式不同分为：联机命令接口和脱机命令接口
	- 联机命令接口：又称为**交互式**命令接口，适用于分时或实时系统的
		- 如：windows的cmd终端（“小黑框”）就是交互式命令接口
		- 用户说一句，系统就做一句
	- 脱机命令接口：又称为**批处理**命令接口，适用于批处理系统，它由一组作业控制命令组成
		- 批处理：将任务写在清单列表上，按照清单一个一个完成
		- 用户说一系列任务，系统再处理一系列任务
##### （2）程序接口

- 程序接口由一组**系统调用**组成
- 用户通过在程序中使用这些系统调用来请求操作系统为其提供服务
- 当前最流行的就是图形应用界面（GUI），即：图形接口
	- 图形接口不是OS的一部分，但其调用的命令是OS的一部分
##### （3）操作系统OS用作扩充机器/虚拟机

- 裸机：没有任何软件支持的计算机
- 扩充机器/虚拟机：覆盖了软件的机器
	- 只有安装了OS的裸机，才能在其上面安装应用程序等
### 四、操作系统的运行环境[^5]
#### 别名

- 内核态 = 核心态 = 管态
- 用户态 = 目态
#### 1. 用户态和核心态/内核态

```
普通程序员写的程序就是应用程序，而实现操作系统的程序则是内核程序，由很多内核程序组成了操作系统内核，或简称为"内核"
```
- 用户态：应用程序运行时，OS处于用户态，CPU只能执行非特权指令
- 核心态/内核态：操作系统内核程序运行在核心态/内核态，CPU可以执行特权指令
#### 2. 内核

- 地位：内核是操作系统中**最重要最核心**的部分，也是**最接近硬件的部分**
- 操作系统的功能未必都在内核中，如：图形化界面GUI；就算没有GUI，也可以使用cmd终端(“小黑框”)来使用操作系统
- 内核：计算机最底层的软件，包含以下四个方面的内容：
	1. 时钟管理：用于计时、时钟中断
		- OS通过时钟管理向用户提供准确的时间，通过时钟中断的管理来实现进程的切换
	2. 中断机制：可提高多道程序环境中CPU的利用率
	3. 原语：是底层的可被调用的小程序
		- 位于操作系统的最底层
		- 具有原子性，其操作不可中断，运行即完成为止
		- 运行时间短，调佣较频繁
		- 定义原语的直接操作就是关中断，在关中断的状态下执行完整个原语操作
	4. 系统控制的数据结构及处理
#### 3. 操作系统的运行机制
##### 本质[^8]

- 发生中断就意味着操作系统的介入，并开展管理工作
- 用户态 $\rightarrow$ 核心态/内核态：通过**中断**实现（触发中断信号意味着操作系统强制夺回CPU的控制权），并且**中断**是**唯一途径**[^2]，`硬件会自动完成转换过程`
	- 在CPU变为内核态后，将会停止运行目前正在运行的应用程序，转而运行一个处理中断信号的内核程序，当内核程序运行完成后，才将CPU使用权再还给应用程序（但不一定是给被中断的那个，可能是不同的应用程序）
- 核心态/内核态 $\rightarrow$ 用户态：通过执行一个**特权指令**，将`程序状态字（PSW）`的标志位设置为用户态
	- `PSW`为`1`时，表示CPU处于"内核态"，`0`表示"用户态"
#### 4. 中断（外中断）和异常（内中断）

##### 内中断/异常/例外/陷入

- 信号来源：CPU内部，与当前指令有关
	- 如果当前指令或指令参数是非法的，则会引发一个中断信号
- 例如：
	1. 资源中断 --- 指令中断（**陷入指令**）
		- 系统调用时使用的**访管指令（又叫陷入指令，trap指令）**，用于请求操作系统内核的服务，该指令就会引发一个内部中断信号
			- 陷入指令是一条比较特殊的指令，但并不是特权指令，它意味着应用程序**主动地**将CPU控制权还给操作系统内核，如“系统调用”就是通过陷入指令完成的
	2. 强迫中断 --- 故障
		- 硬件**故障**（如：缺页故障）或软件中断（如：整数除`0`）
		- 由错误条件引起，可能被内核程序修复。修复故障后，CPU使用权将会还给应用程序，让它继续执行下去
	3. 终止
		- 由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引起终止的应用程序，而是直接终止该应用程序。如：整数除`0`，非法使用特权指令等
##### 外中断/中断

- 作用：“中断”是让操作系统内核（管理者）夺回CPU使用权的**唯一途径**
- 信号来源：CPU外部，与当前指令无关
- 例如：时钟中断
	1. 外设请求
		- I/O操作完成发出的中断信号
	2. 人工干预
		- 用户强制终止一个进程
#### 5. 中断机制的基本原理

##### 检查中断信号
###### 内中断

- CPU在执行指令时会检查是否有异常发生
###### 外中断

- 每个指令周期末尾，CPU都会检查是否有外中断信号需要处理
##### 找到相应的中断处理程序
```
不同的中断程序，需要用不同的中断处理程序来处理
```
- 当CPU检测到中断信号后，会根据中断信号的类型去查询“**中断向量表**”，以此来找到相应的中断处理程序在内存中的位置
	- 例图：![](assets/Pasted%20image%2020241201214035.png)
	- 显然，**中断处理程序一定是内核程序**，需要运行在**内核态**


### 五、系统调用
#### 系统调用定义

- 操作系统对应用程序/程序员提供的接口
#### 系统调用和库函数的区别

|      | 功能                                                 |
| :--: | :--------------------------------------------------: |
| 普通程序 | 可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的则不涉及               |
| 编程语言 | **向上**提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序变编程更加方便 |
| 操作系统 | **向上**提供系统调用，使得上层程序能请求内核的服务                        |
|  裸机  |                                                    |
- **不涉及**系统调用的库函数，如："取绝对值"的函数
- **涉及**系统调用的库函数，如："创建一个新文件"的函数 $\rightarrow$ 请求操作系统内核的服务 $\rightarrow$ 特权指令
>[!tip] 注意！！！
>凡是与共享资源有关的操作（如：存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作

#### 为什么系统调用是必须的？

- 举个例子，假如目前只有一台打印机，而同时有两人在使用这台打印机打印他们各自的文件，那么此时，如果不使用系统调用，就会导致他们两人的文件材料内容会混淆在一起被打印出来
	- 系统调用就是由系统进行协调
#### 系统调用的过程

- 传递系统调用参数 $\rightarrow$ 执行陷入指令（`用户态`）$\rightarrow$ 执行相应的内核程序处理系统调用请求（`核心态`）$\rightarrow$ 返回应用程序
	- **陷入指令**是在**用户态**执行的，执行陷入指令之后立即引发一个**内中断**，使CPU进入**核心态**
	- **发出系统调用请求**是在**用户态**，而**对系统调用的相应处理**在**核心态**下进行
### 六、操作系统的体系结构

注意框内事项[^9]
```
这一小节中，我们说的变态操作是为了方便叙述，在考试时需要使用正式称呼：CPU状态的转换
```
#### 1. 操作系统的内核

- 图例示范说明/示例图：![](assets/Pasted%20image%2020241202114622.png)
- **内核**是操作系统**最基本、最核心**的部分。实现操作系统内核功能的那些程序就是**内核程序**。
#### 2. 操作系统内核的两种设计方式/方案[^10]
- 一图实例/示例图/说明图：![](assets/Pasted%20image%2020241202115508.png)
- 左手边的设计方式是将操作系统的主要功能模块都作为系统内核，称为`"大内核"`
- 右手边的设计方式只保留了与硬件关系最紧密的功能部分，称为`“微内核”`
>[!tip] 注意！！！
>操作系统**内核**需要运行在**内核态**
>操作系统的**非内核**功能运行在**用户态**
##### (1)大内核：

- 一图实例/示例图：
![](assets/Pasted%20image%2020241202133750.png)
- 大内核请求操作系统的服务时只需要进行**两次变态**
- 典型的`大内核/宏内核/单内核`操作系统：LINUX、UNIX
###### 优点：

- 高性能
	- 因为应用程序在申请内核服务时经历的变态过程较少
###### 缺点：

- 内核代码庞大，结构混乱，难以维护
##### (2)微内核：

- 一图实例/示例图：
![](assets/Pasted%20image%2020241202133849.png)
- 微内核请求操作系统的服务需要进行**六次变态**
- 典型的`微内核`操作系统：Windows NT
- 如果进程管理需要调用存储管理的接口，那么也需要通过请求内核服务，来让内核调用进程管理，这过程中就用到了消息传递
###### 优点：

- 内核功能少，结构清晰，方便维护
###### 缺点：

- 需要频繁地在核心态和用户态之间切换，性能较低
##### (3)大内核、微内核总结

-  如果一个应用程序想要请求操作系统的服务，这个服务的处理会同时涉及到进程管理、存储管理、设备管理
>[!tip] 注意！！！
>变态的过程是**有成本**的，要消耗不少时间，**频繁地变态会降低系统性能**
#### 3. 分层结构

- 最底层是硬件，最高层是用户接口，每层可以调用更第一层，不能跨层调用
##### 优点：

1. 便于调试和验证，自底向上逐层调试验证🌟
2. 易扩充和易维护，各层之间调用接口清晰固定
##### 缺点：

1. 只能调用`相邻`**低层**，难以合理定义各层的边界
	- 有时候需要相邻的高低层互相调用接口，像分层结构这样的严格区分高层调用低层的很难界定边界
2. 效率低，不能跨层调用，系统调用执行时间长🌟
	- 假如用户接口需要调用底层硬件接口，那么就需要逐层往下调用，效率较低
#### 4. 模块化🌟

- 将内核划分为多个模块，各个模块之间互相协作

- 内核 = 主模块 + 可加载内核模块
	- 主模块：只负责核心功能，如：**进程**调度、**内存**管理
	- 可加载内核模块：可以**动态加载**新模块到内核，而无需重新编译整个内核，如：设备的驱动程序
##### 优点：

1. 模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发
	- 因为模块化的设计中，我们是按逻辑功能来划分模块的
2.  🌟支持动态加载新的内核模块（如：安装设备驱动程序、安装新的文件系统模块到内核），增强OS适应性
3. 🌟任何模块都可以**直接调用**其他模块，无需采用消息传递进行通信，效率高
##### 缺点：

1. 模块间的接口定义未必合理、实用
2. 模块间相互依赖，更难调试和验证
#### 5. 宏内核（大内核、单内核）

- 所有的系统功能都放在内核中（大内核结构的OS通常也采用了`“模块化”`的设计思想）
##### 优点：

1. ⭐性能高，内核内部各种功能都可以**直接相互调用**
##### 缺点：

1. ⭐内核庞大，功能复杂，难以维护
2. ⭐大内核中某个功能模块出错，就可能导致整个系统崩溃
#### 6. 微内核

- 只把`中断、原语、进程通信、时钟管理`等最核心的功能放入内核。进程管理、文件管理、设备管理等功能以用户进程的形式存在于用户态
##### 优点：

1. ⭐内核小，功能少，易于维护，内核可靠性高
2. ⭐内核外的某个功能模块出错不会导致系统崩溃（区别于大内核的模块出错导致系统崩溃）
##### 缺点：

1. 性能低，需要频繁的切换`用户态/核心态`。用户态下的各功能模块不可以直接互相调用，只能通过内核的`“消息传递”`来**间接通信**（模块化、大内核都可以直接相互调用，都是直接通信）
#### 7. 外核（exokernel）🌟

```
这种结构的OS非常少见
```
- 内核负责进程调度、进程通信等功能，**外核**负责为用户进程分配**未经抽象的**硬件资源，且由外核负责保证资源使用安全
	- 普通的操作系统给用户分配的磁盘空间是经过抽象的连续空间，在实际的内存空间中，这些空间大概率是离散分布的
	- 假设用户申请的这块磁盘空间在未来可能会被频繁的随机访问，那么就向**外核**申请一块连续的、未经抽象的磁盘空间，这可以有效提升访问性能，减少磁头的频繁变化，内存空间的申请分配也同理
>[!tip] 注意！！！
>**外核**能为用户进程分配硬件资源，而**内核**也可以为用户进程分配硬件资源，只是在特定情况下由外核分配未经抽象的硬件资源，通常情况下仍然由**内核来分配经过抽象的硬件资源**

- 结构示意图/示例图：![](assets/Pasted%20image%2020241202151829.png)

##### 优点：

1. 🌟外核可以直接给用户进程分配`“不虚拟、不抽象”`的硬件资源，使用户进程可以更灵活的使用硬件资源
2. 🌟减少了虚拟硬件资源的`“映射层”`，提升效率
	- 因为普通的操作系统给用户进程分配的都是虚拟的硬件资源，如：虚拟内存等，则用户进程在访问自己的地址空间时，只能提供虚拟地址，`OS`需要去页表中查询，可能需要查询多级页表才能将虚拟地址转换为物理地址，这个过程就是**虚拟地址到物理地址的映射**
##### 缺点：

1. 降低了系统的一致性
	- 在外核OS中，一个进程申请的可能是抽象的硬件资源（内核分配，需要映射），也可能是未经抽象的硬件资源（外核分配）
2. 使系统变得更加复杂
### 七、操作系统引导
#### 1. 什么是操作系统引导？

- 简而言之，操作系统引导（boot）就是引导开机时如何让操作系统运行的过程。
#### 2. 各个部件结构
##### （1）主存

- 结构图/示例图如下：![](assets/Pasted%20image%2020241202153356.png)
##### （2）磁盘

- 结构如下：

| 主引导记录（MBR）（包含：磁盘引导程序和分区表） | C：盘 | D：盘 | E：盘 | F：盘 |
| :-----------------------: | :-: | :-: | :-: | :-: |
其中，装有操作系统的盘（大多为C：盘）中，存在如下结构：

| 引导记录PBR（负责找到“启动管理器”） | 根目录 | 其他  |
| :------------------: | :-: | :-: |
- 结构图/示例图如下：![](assets/Pasted%20image%2020241202153824.png)
#### 3. 具体执行步骤：

1. CPU从一个特定主存地址（ROM）开始，取指令，执行`ROM`中的引导程序（先进行硬件自检，在开机）
2. 将磁盘的第一块 ---- 主引导记录读入内存，执行磁盘引导程序，扫描分区表
3. 从**活动分区**（又称**主分区**，即安装了操作系统的分区，通常为C：盘）读入分区引导记录，执行其中的程序
4. 从根目录下找到`完整的操作系统初始化程序（即：启动管理器）`，并执行，完成“开机”的一系列动作
- 图表表示/过程示例图：![](assets/Pasted%20image%2020241202154745.png)
### 八、虚拟机

```
一台物理机器只能运行一个操作系统
```
#### 1. 定义

- 虚拟机：使用虚拟化技术，使一台物理机器虚拟化为多台虚拟化机器（virtual Machine ，VM），每个虚拟机器都可以独立运行一个操作系统
#### 2. 同义词

1. 虚拟机管理程序
2. 虚拟机监控程序
3. Virtual Machine Monitor （VMM）
4. Hypervisor
#### 3. 分类
##### （1）第一类VMM：直接运行在硬盘上

- 示例图/结构图：![](assets/Pasted%20image%2020241203161854.png)
- 将一个物理机虚拟化为多个虚拟机，会将一个总的硬件资源划分为多个部分，以供各个虚拟机使用，每个虚拟机都可以安装各自不同的操作系统，并可以在各自的OS上运行各自的进程
- 单核CPU的分配：将CPU的使用分为多个时间片，将时间片分配给每个虚拟机，在每个虚拟机看来，它们都享有了一个单独的CPU
- 只有虚拟机管理程序是运行在内核态的，可以使用最高特权的指令，它**直接**运行在硬件之上，**直接**对硬件资源进行分配
- 上层的操作系统和应用程序都是运行在用户态的，这可能会导致一些问题：
	- 上层的操作系统仍然会使用一部分特权指令，但它**实际上是运行在用户态**的，是无法执行特权指令的，此时，处于内核态的第一类虚拟机管理程序将会截获它的这一指令，并通过一系列操作将该指令的执行结果**模拟**出来，让上层操作系统以为它成功执行了这一特权指令
##### （2）第二类VMM：运行在宿主操作系统上

- 示例图/结构图：![](assets/Pasted%20image%2020241203163830.png)
- 第二类VMM中，宿主操作系统的应用程序和虚拟机中的应用程序可以同时正常运行，不会发生冲突
- 第二类VMM是运行在宿主操作系统上的
- 第二类VMM无法直接分配硬件资源，如果其需要硬件资源，那么就需要向宿主操作系统申请
#### 4. 🌟两类VMM的对比/比对/区别/差别

|                 |                                            第一类VMM                                            |                                          第二类VMM                                           |
| :-------------: | :------------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------: |
|    对物理资源的控制权    |                                    直接运行在硬件上，能直接控制和分配物理资源                                     |                          运行在Host OS（宿主操作系统）之上，依赖于Host OS为其分配物理资源                          |
| 资源分配方式（给上层分配资源） | 在安装Guest OS（即：新安装的OS）时，VMM要在原本的硬盘上自行分配存储空间，类似于“外核”的分配方式，分配**未经抽象**的物理硬件（就是直接将一整块硬件资源分配给上层OS） | Guest OS拥有自己的虚拟磁盘，该盘实际上是Host OS文件系统中的一个大文件（存储路径由宿主OS决定）。Guest OS分配到的内存是虚拟内存（该虚拟内存不一定是连续的） |
|       性能        |                                             性能更好                                             |          性能更差，需要Host OS作为“中介”（虚拟机要给应用程序分配资源时，只能找到其虚拟地址，需要不断映射，直到宿主OS中找到对应的物理地址）           |
|    可支持的虚拟机数量    |                             更多，不需要和Host OS竞争资源，相同的硬件资源可以支持更多的虚拟机                             |                       更少，Host OS本身也需要使用物理资源，Host OS上运行的其他进程也需要物理资源                        |
|    虚拟机的可迁移性     |                                              更差                                              |                         更好，只需要导出虚拟机镜像文件即可迁移到另一台Host OS上，商业化应用更广泛                          |
|      运行模式       |                          第一类VMM运行在最高特权级（Ring 0 --- 0环），可以执行最高特权的指令                           |            第二类VMM部分运行在用户态，部分运行在内核态。Guest OS发出的系统调用会被VMM截获，并转化为VMM对Host OS的系统调用            |
##### 第一类VMM

- 第一类VMM特权级别划分：
	- 虚拟机管理程序 $\rightarrow$ Ring 0 --- 最高级
	- 虚拟内核空间（VM1，VM2，... ----- 虚拟机）$\rightarrow$ Ring 1 --- 次高级
	- 虚拟机中的应用程序 $\rightarrow$ Ring 2
- 在虚拟机运行`Ring 0`级以下的特权指令时，不进行检查，直接允许其运行，当这些虚拟机运行了`Ring 0`级的命令时，虚拟机管理程序才会对该最高级特权指令进行检查判断，如果无危害才允许其运行
##### 第二类VMM

- 在内核态的部分是以**虚拟机驱动程序**的方式加载到操作系统内核中的
- 当虚拟机中的应用程序请求系统调用时，该请求会被第二类虚拟机管理程序截获，在进行一些处理后，再代替该应用程序向宿主操作系统申请系统调用





[^1]: 处理机管理和存储器管理是一部分重点
[^2]: 中断，重点
[^3]: 必考点1：OS基本概念
[^4]: 必考点2：OS特征
[^5]: 必考点3：OS运行环境
[^6]: 重要考点：多核CPU和单核CPU
[^7]: 重点
[^8]: 用户态和核心态的切换
[^9]: 变态过程的相关注意事项
[^10]: 大内核和微内核的优缺点