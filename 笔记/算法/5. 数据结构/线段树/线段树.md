# çº¿æ®µæ ‘

---

### ä¸€ã€åŸç†

1. push upæ“ä½œï¼šç”±å­èŠ‚ç‚¹å»è®¡ç®—çˆ¶èŠ‚ç‚¹çš„ä¿¡æ¯
2. push downæ“ä½œï¼ˆä¹Ÿç§°ä¸º**æ‡’æ ‡è®°**ã€å»¶è¿Ÿæ ‡è®°ï¼‰ï¼šæŠŠå½“å‰çˆ¶èŠ‚ç‚¹çš„ä¿®æ”¹ä¿¡æ¯ä¸‹ä¼ ç»™å­èŠ‚ç‚¹
3. æ‰«æçº¿

çº¿æ®µæ ‘ç»“æ„ï¼š
![](assets/Pasted%20image%2020250509195117.png)

çº¿æ®µæ ‘é™¤äº†æœ€åä¸€å±‚å¤–ï¼Œæ˜¯ä¸ªæ»¡äºŒå‰æ ‘ï¼Œå¯ä»¥ç”¨ä¸€ç»´æ•°ç»„å­˜æ•´æ£µæ ‘
ğŸŒŸğŸŒŸğŸŒŸè‹¥ç¼–å·ä¸º x çš„èŠ‚ç‚¹ï¼Œå…¶çˆ¶èŠ‚ç‚¹ä¸º $x >> 1$ ï¼ˆä¸‹å–æ•´ï¼‰ï¼Œå·¦å„¿å­ä¸º $2x\;(æˆ–ï¼šx<<1)$ ï¼Œå³å„¿å­ä¸º $2x+1\;(x<<1|1)$ ï¼ˆx å·¦ç§» 1 æˆ– 1ï¼‰

å¼€æ•°ç»„æ—¶éœ€è¦å¼€ 4n - 1 çš„ç©ºé—´

åªæœ‰æ¶‰åŠåŒºé—´ä¿®æ”¹çš„ï¼Œæ‰ä¼šç”¨åˆ°æ‡’æ ‡è®°ï¼Œå³ï¼špushdown

### äºŒã€ä»£ç åŠŸèƒ½å®ç°
#### åŸºæœ¬æ“ä½œ

1. pushupï¼ˆuï¼‰
2. buildï¼ˆï¼‰ï¼šå°†ä¸€æ®µåŒºé—´åˆå§‹åŒ–ä¸ºçº¿æ®µæ ‘
3. modifyï¼ˆï¼‰ï¼š
	1. ä¿®æ”¹å•ç‚¹
	2. ä¿®æ”¹åŒºé—´ï¼ˆpushdownï¼‰ ----- ç”¨åˆ°æ‡’æ ‡è®°
4. queryï¼ˆï¼‰ï¼šæŸ¥è¯¢æŸæ®µåŒºé—´çš„ä¿¡æ¯
5. çº¿æ®µæ ‘æ˜¯åŠ¨æ€ç»´æŠ¤çš„
#### build æ“ä½œ

é€’å½’å»ºæ ‘buildï¼šO(n)
```C++
void build(int u, int l, int r)
{
	tr[u] = {l, r};// å½“å‰èŠ‚ç‚¹çš„å·¦å³å„¿å­
	if (l == r) return ;// å¦‚æœå·²ç»æ˜¯å¶å­ç»“ç‚¹äº†ï¼Œå°±ä¸å†é€’å½’
	int mid = tr[u].l + tr[u].r >> 1;
	build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);// é€’å½’å»ºç«‹å·¦å³åŒºé—´
	pushup(u); // æ›´æ–°çˆ¶èŠ‚ç‚¹
}
```

#### lazyæ ‡è®°

```
é€‚ç”¨äºåŒºé—´ä¿®æ”¹æ“ä½œ

ä¼˜åŒ–å‰ï¼š
	å•ç‚¹æ›´æ–°ï¼šO(logâ¡n)
	åŒºé—´æ›´æ–°ï¼šO(nlogâ¡n)
	åŒºé—´æŸ¥è¯¢ï¼šO(logâ¡n)
ä¼˜åŒ–åï¼š
	å•ç‚¹æ›´æ–°ï¼šO(logâ¡n)
	åŒºé—´æ›´æ–°ï¼šO(logâ¡n)
	åŒºé—´æŸ¥è¯¢ï¼šO(logâ¡n)
```

```C++
// å‡å®šç›®å‰çš„é¢˜ç›®åœºæ™¯ä¸ºï¼Œæ±‚æŒ‡å®šåŒºé—´èŒƒå›´å†…çš„å…ƒç´ æ€»å’Œ
struct Node
{
	int l, r, sum, add; // l,råˆ†åˆ«è¡¨ç¤ºåŒºé—´å·¦å³ç«¯ç‚¹;sum è¡¨ç¤ºåŒºé—´æ€»å’Œ,addè¡¨ç¤ºæ‡’æ ‡è®°ï¼Œå³ï¼šåŒºé—´ä¿®æ”¹çš„å€¼
}tr[N * 4];

void pushup(int u) // å¾€ä¸Šä¼ ï¼Œç”±å­èŠ‚ç‚¹æ›´æ–°çˆ¶èŠ‚ç‚¹
{
	tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
}

void pushdown(int u) // åŒºé—´ä¿®æ”¹ï¼Œæ‡’æ ‡è®°ä¸‹ä¼ 
{
	if (tr[u].add) // å¦‚æœå­˜åœ¨æ‡’æ ‡è®°ï¼Œåˆ™ä¸‹ä¼ 
	{
		tr[u << 1].sum += tr[u].add * (tr[u << 1].r - tr[u << 1].l + 1);
		tr[u << 1 | 1].sum += tr[u].add * (tr[u << 1 | 1].r - tr[u << 1 | 1].l +1);
		tr[u << 1].add += tr[u].add;
		tr[u << 1 | 1].add += tr[u].add;
		tr[u].add = 0;
	}
}

// query å’Œ update æ“ä½œéƒ½éœ€è¦ç”¨åˆ° pushdown
void update(int u, int l, int r, int x)
{
	if (tr[u].l >= l && tr[u].r <= r)
	{
		tr[u].sum += (tr[u].r - tr[u].l + 1) * x;
		tr[u].add += x;
		return ;
	}
	int mid = tr[u].l + tr[u].r >> 1;
	pushdown(u); // æ›´æ–°å­èŠ‚ç‚¹å‰ï¼Œå…ˆä¸‹ä¼ æ‡’æ ‡è®°
	if (l <= mid) update(u << 1, l, r, x);
	if (r > mid) update(u << 1 | 1, l, r, x);
	pushup(u); // æ›´æ–°çˆ¶èŠ‚ç‚¹
}

int query(int u, int l, int r)
{
	if (tr[u].l >= l && tr[u].r <= r) 
		return tr[u].sum;
	int sum = 0;
	int mid = tr[u].l + tr[u].r >> 1;
	pushdown(u); // éå†å­èŠ‚ç‚¹ä¹‹å‰å…ˆä¸‹ä¼ æ‡’æ ‡è®°
	if (l <= mid) sum += query(u << 1, l, r);
	if (r > mid) sum += query(u << 1 | 1, l, r);
	return sum;
}

```

### ä¸‰ã€é€‚ç”¨åœºæ™¯

ä¸åŒäºæ ‘çŠ¶æ•°ç»„ä»…é€‚ç”¨äºå•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ï¼Œçº¿æ®µæ ‘ç®—æ³•ä¸ä»…å¯å®ç°å•ç‚¹ä¿®æ”¹ï¼Œè¿˜å¯å®ç°åŒºé—´ä¿®æ”¹ï¼Œå¯ç”¨äºæ±‚åŒºé—´å†…æå€¼ã€æœ€å€¼ç­‰æƒ…å†µ

### å››ã€ä¾‹é¢˜

```C++
// æ±‚åŒºé—´çš„æœ€å¤§è¿ç»­å­æ®µå’Œï¼Œæ¶‰åŠå•ç‚¹ä¿®æ”¹
// å› ä¸ºè¦æ±‚åŒºé—´å†…çš„æœ€å¤§è¿ç»­å­æ®µå’Œï¼Œæ‰€ä»¥è¦è€ƒè™‘è¯¥æœ€å¤§å­æ®µæ‰€åœ¨ä½ç½®ï¼Œåˆ¤æ–­å…¶åœ¨å·¦åŒºé—´ã€å³åŒºé—´ï¼Œäº¦æˆ–æ˜¯æ¨ªè·¨å·¦å³åŒºé—´ï¼Œæ‰€ä»¥ä¸ä»…éœ€è¦è®°å½•çº¿æ®µæ ‘åŒºé—´çš„æœ€å¤§å­æ®µå’Œ
//è¿˜è¦è®°å½•å·¦åŒºé—´çš„æœ€å¤§åç¼€å’Œä¸å³åŒºé—´çš„æœ€å¤§å‰ç¼€å’Œï¼Œè¿™ä¸¤è€…åœ¨å…¶çˆ¶èŠ‚ç‚¹åŒºé—´å¤„æ˜¯è¿ç»­çš„ï¼Œæ‰€ä»¥éœ€è¦åˆ¤æ–­å‰ç¼€å’Œä¸åç¼€å’Œçš„å’Œæ˜¯å¦æ¯”å·¦å³åŒºé—´å†…çš„æœ€å¤§å‰ç¼€å’Œå¤§
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 500010;

int n, m;
int w[N];
struct Node
{
    int l, r;
    int sum, lmax, rmax, tmax; // åŒºé—´æ€»å’Œï¼ˆå› ä¸ºè¦è€ƒè™‘å·¦åŒºé—´ + å³åŒºé—´æœ€å¤§å‰ç¼€å’Œï¼Œå¯èƒ½æ¯”å·¦åŒºé—´æœ€å¤§åç¼€å’Œ + å³åŒºé—´æœ€å¤§å‰ç¼€å’Œ æ›´å¤§ï¼‰ï¼Œæœ€å¤§åç¼€å’Œï¼ˆå·¦åŒºé—´ï¼‰ï¼Œæœ€å¤§å‰ç¼€å’Œï¼ˆå³åŒºé—´ï¼‰å’ŒåŒºé—´å†…æœ€å¤§è¿ç»­å­æ®µå’Œ
}tr[N * 4];

void pushup(Node &u, Node &l, Node &r) // u è¡¨ç¤º l å’Œ r çš„çˆ¶èŠ‚ç‚¹ï¼Œl è¡¨ç¤ºå·¦å„¿å­ï¼Œr è¡¨ç¤ºå³å„¿å­
{
    u.sum = l.sum + r.sum;
    u.lmax = max(l.lmax, l.sum + r.lmax);
    u.rmax = max(r.rmax, l.rmax + r.sum);
    u.tmax = max(l.rmax + r.lmax, max(l.tmax, r.tmax));
}

void pushup(int u)
{
    pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);
}

void build(int u, int l, int r)
{
    if (l == r) tr[u] = {l, r, w[r], w[r], w[r], w[r]};  // æœ€å¤§å­æ®µå’Œè‡³å°‘åŒ…å«ä¸€ä¸ªæ•°ï¼Œæ‰€ä»¥å­˜ä¸º w[r] 
    else
    {
        tr[u] = {l, r}; // éå¶å­ç»“ç‚¹ï¼Œåˆ™è®°å½•å…¶å·¦å³å„¿å­
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u); // ç”±å­èŠ‚ç‚¹æ›´æ–°çˆ¶èŠ‚ç‚¹
    }
}

void modify(int u, int x, int v)
{
    if (tr[u].l == x && tr[u].r == x) tr[u] = {x, x, v, v, v, v}; // æ‰¾åˆ°è¯¥å•ç‚¹ï¼Œä¿®æ”¹å€¼
    else 
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (x <= mid) modify(u << 1, x, v);
        else modify(u << 1 | 1, x, v);
        pushup(u);
    }
}

Node query(int u, int l, int r)
{
    if (tr[u].l >= l && tr[u].r <= r) return tr[u];
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (r <= mid) return query(u << 1, l, r); // å¦‚æœåŒºé—´[l, r]åœ¨å·¦å„¿å­åŒºé—´ï¼Œåˆ™å¾€å·¦æ‰¾
        else if (l > mid) return query(u << 1 | 1, l, r); // å¦‚æœåŒºé—´[l, r] åœ¨å³å„¿å­åŒºé—´ï¼Œåˆ™å¾€å³æ‰¾
        else // å¦‚æœæ˜¯æ¨ªè·¨å·¦å³å„¿å­åŒºé—´
        {
            Node left = query(u << 1, l, r); // æ‰¾åˆ°å·¦å„¿å­éƒ¨åˆ†, å› ä¸º r > midï¼Œæ‰€ä»¥å·¦å„¿å­éƒ¨åˆ†ä¸€å®šæ»¡è¶³ tr[u].r <= r
            Node right = query(u << 1 | 1, l, r); // æ‰¾åˆ°å³å„¿å­éƒ¨åˆ†ï¼ŒåŒæ ·çš„ï¼Œå› ä¸º l <= mid, å³å„¿å­éƒ¨åˆ†ä¸€å®šæ»¡è¶³ tr[u].l >= l
            // æ•…ä¹Ÿå¯å†™ä½œï¼šleft = query(u << 1, l, mid), right = query(u << 1 | 1, mid + 1, r);
            Node res;
            pushup(res, left, right); // ç”¨å­èŠ‚ç‚¹æ›´æ–°çˆ¶èŠ‚ç‚¹ï¼Œæ‰¾å‡ºæœ€å¤§å­æ®µå’Œ
            return res;
        }

    }
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++) cin >> w[i];

    build(1, 1, n);

    while(m --)
    {
        int k, x, y;
        cin >> k >> x >> y;
        if (k == 2)
        {
            modify(1, x, y);
        }
        else if (k == 1)
        {
            if (x > y) swap(x, y);
            cout << query(1, x, y).tmax << endl;
        }
    }

    return 0;
}
```