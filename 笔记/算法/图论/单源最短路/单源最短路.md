# 单源最短路

---

### 分类
#### 边权非负
##### 1. 朴素Dijstra算法

- 适用于稠密图，时间复杂度为$O(n^2)$
##### 2. 堆优化版Dijstra算法

- 适用于稀疏图，时间复杂度为$O(m \log n)$，m 为询问次数，n 为建图的点个数
#### 有负边权

大多数情况均使用SPFA算法，仅少数情况使用Bellman-ford算法，所以只需要了解SPFA算法（平均时间复杂度为$O(M)$）即可

### 难点/重点

最难的是问题的转化与抽象，如何将问题转化为对应的模板问题

### 建图
#### 邻接表建图

```C++
void add(int a, int b, int c) // 建立一条由 a 指向 b 的边
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
} // e：当前边的终点（即 b），ne：下一条边的终点

假设我们有 1, 2, ..., n 个点，则用邻接表建图，一共有 n 个邻接表
若需要建立一条由 1 指向 2 的边，边权为 c，则 add(1, 2, c)，使得在邻接表a 的表头 h[1] 后建立了一条指向 2 的边，即：
h[1]: 2 → -1
若再添加一条边，使得 1 指向 3，边权为 c，则 add(1, 3, c)，得到邻接表:
h[1]: 3 → 2 → -1
```
### 例题
#### 热浪

```C++
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 2510, M = 6200 * 2 + 10;
int n, m, S, T; // 点数，边数，起点，终点
int h[N], e[M], w[M], ne[M], idx; // 邻接表存储
int dist[N], q[N];
bool st[N];

void add(int a, int b, int c) // 建立一条由 a 指向 b 的边
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

void spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[S] = 0; // 起点距离设置为 0
	 //因为是循环队列，所以要保证初始条件 hh != tt 能成立，我们正常使用模拟队列可能习惯了使 hh = 0, tt = 0，并用 while(hh <= tt)来作为循环条件，所以可能对此处的 tt = 1心存疑惑。其实很简单，此处需要保证循环队列成立，故 tt 指向的是下一空位，而非指向队尾元素；若 hh == tt，则说明循环队列中不存在
	 // tt 始终指向下一可插入的位置，hh 指向当前待处理元素的位置
    int hh = 0, tt = 1; // 注意循环队列初始条件
    q[0] = S, st[S] = true;
    // 使用循环队列是因为每次更新最短距离路径都可能加入新的节点
    while(hh != tt) // 队列不空的判断是 hh != tt, 也可以直接用queue<int> q[N], 这样就不用写 if(hh == N) h = 0 来模拟循环队列了
    {
        int t = q[hh ++];
        if (hh == N) hh = 0;
        st[t] = false; // 将 t 出队，清除 st

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            // 只有当经过某一节点，并更新了最短路径，才可能是最短路径所在的节点，所以才能加入队列？
            if (dist[j] > dist[t] + w[i]) // 更新最短路
            {
                dist[j] = dist[t] + w[i];
                if (!st[j]) // 判断该点是否已经在队列中，避免重复处理同一个点
                {
                    q[tt ++] = j; // 
                    if (tt == N) tt = 0;
                    st[j] = true;
                }
            }
        }

    }
}

int main()
{
    cin >> n >> m >> S >> T;
    memset(h, -1, sizeof h); // 初始化表头不能忘

    for (int i = 0; i < m; i ++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c), add(b, a, c);
    }
    spfa();

    cout << dist[T] << endl;

    return 0;
}
```